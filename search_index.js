var documenterSearchIndex = {"docs":
[{"location":"quickstart/#Quick-Start-Guide","page":"Quick Start","title":"Quick-Start Guide","text":"","category":"section"},{"location":"quickstart/#Installation-and-Setup","page":"Quick Start","title":"Installation and Setup","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"note: Multi-threading\nJuliaDispatch uses multi-threading to speed up the process of parsing patches. It is recommend you start your Julia session with more than one thread. This can be done by typing julia -threads N when starting Julia, where N is the number of threads. You can also do this using the environment variable by setting export JULIA_NUM_THREADS=N. See docs for more information.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Open your Julia REPL terminal and type ']' to enter the package manager, followed by","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"pkg> add \"https://github.com/casparwb/JuliaDispatch.jl\"","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"After having installed the packages, exit the package manager with backspace, and type","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using JuliaDispatch","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Note that things will be quite slow the first time you add and import a package, in addition to when you call a function. This is due to Julia's precompilation routine, and only happens the first time you call a function.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Importing JuliaDispatch does not include any functions into your workspace, but rather allows you to load the individual modules. These modules are","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Dispatch: this submodule contains the snapshot(...) function which allows reading in a snapshot and saving all the metadata into a dictionary.\nGraphics: high-level plotting of slices (planes), volumes, and 1-d quantities.\nBuffers: methods for stitching together patch data into 2- or 3-dimensional arrays, in addition to resampling methods for re-sizing the domain.\nSelect: methods for extracting patches and data at given positions in the computational domain.\nUtils:  various QOL tools, such as functions for getting the number of snapshots in a folder, among other things.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"After having imported JuliaDispatch, you can include the functionality of any of these modules by doing","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using JuliaDispatch.MODULENAME","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"where MODULENAME is replaced by any of the abovementioned modules. Note that the module name is case-sensitive, and all modules have a capital first letter. You can also directly use a function within a module without explicitly importing it by doing","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"JuliaDispatch.MODULENAME.funcname(args...)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"where funcname is the name of the function exported by the module MODULENAME. ","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"To quickly get the documentation for any function, use the help functionality of the REPL, which you can enter by typing ?. You can then enter a function for which you want the documentation. For example","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"?\nsnapshot","category":"page"},{"location":"quickstart/#Functionality","page":"Quick Start","title":"Functionality","text":"","category":"section"},{"location":"quickstart/#Snapshots","page":"Quick Start","title":"Snapshots","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The snapshot function returns a dictionary object. To access any of the snapshot's properties, use square brackets and strings. For example","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"time = snapshot[\"time\"]\nprintln(time)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"gives you the time at which the snapshot was taken. To get all the properties of the snapshot, you can print all the keys or iterate over all key-value pairs","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"println(keys(snap))\n# or\nfor (key, value) in snap\n    println(key, \" \", value)\nend","category":"page"},{"location":"quickstart/#Quantities","page":"Quick Start","title":"Quantities","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"To see which quantities are present in the snapshot, you can print the [\"idx\"][\"dict\"] of a snapshot. This returns a dictionary with keys equal to the different quantites, and values as integers corresponding to their offset in the data files. Any quantity that has a value < 0 is present and can be extracted from the data files.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using JuliaDispatch, JuliaDispatch.Dispatch, JLD\ndata = \"../../test/data/orz/data/\" # hide\nsnap = snapshot(0, data=data)\nfor (k, v) in snap[\"idx\"][\"dict\"]\n    println(k, \" \", v)\nend","category":"page"},{"location":"quickstart/#Expression-Parsing","page":"Quick Start","title":"Expression Parsing","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The JuliaDispatch package has support for parsing expressions. This means that when extracting patch data, instead of requesting a quantity in a specific data slot, a string containing an expression can be sent in instead. The expression parser will then attempt to parse and evaluate the expression and the return the result for the given patch. Any function that accepts the iv keyword argument supports this functionality. Variables in your workspace can be interpolated into the expression using the $ construct. Example","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"pi = 3.14 #\npatch = snap[\"patches\"][1] # get the first patch\nvelocity = patch[\"var\"](\"$pi*sqrt(ux^2 + uy^2 + uz^2)\") # equivalent to \"3.14*sqrt(ux^2 + uy^2 + uz^2)\"","category":"page"},{"location":"quickstart/#Data-Interpolation","page":"Quick Start","title":"Data Interpolation","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"One of the main features of the package is the ability to stitch together and interpolate patch data. This can be done with both unigrid and mesh-refined simulations. Additionally, data can be up or downscaled to any given dimensions in order to either increase resolution or save memory. This functionality is exported by the JuliaDispatch.Buffers module. See [REF BUFFERS] for details.","category":"page"},{"location":"quickstart/#Usage-Examples","page":"Quick Start","title":"Usage Examples","text":"","category":"section"},{"location":"quickstart/#Loading-a-Snapshot","page":"Quick Start","title":"Loading a Snapshot","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using JuliaDispatch\nusing JuliaDispatch.Dispatch\ndata = \"../test/data/orz/data\" # hide\nsnap = snapshot(100, data=data) # data is a string variable pointing to the folder containing the snapshots\nprintln(\"Snapshot time: $(snap[\"time\"])\") # get the time the snapshot was taken\nprintln(\"Number of patches = $(length(snap[\"patches\"]))\") # print the number of patches","category":"page"},{"location":"quickstart/#Extracting-Interpolated-Data","page":"Quick Start","title":"Extracting Interpolated Data","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using JuliaDispatch.Buffers\n\ndensity_plane = unigrid_plane(snap, iv=\"d\", z=0.1) # get the density in the xy-plane at z=0.1\ndensity_plane_downscaled = amr_plane(snap, iv=\"d\", z=0.1, dims=(200, 300)) # amr_plane can be used to downscale/upscale data\n\ndensity_volume = unigrid_volum(snap, iv=\"d\") # similar for a 3D volume\ndensity_volume_downscaled = amr_volume(snap, iv=\"d\", dims=100)","category":"page"},{"location":"quickstart/#Plotting","page":"Quick Start","title":"Plotting","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using JuliaDispatch.Graphics\n\nsliceplot(snap, iv=\"d\", z=1.0) # plot a simple sliceplot of density at z=1.0\nsliceplot(snap, iv=\"sqrt(bx^2+by^2+bz^2)\", y=-10) # plot an expression\nsliceplot(snap, iv=\"d\", z=0.1, center=(3, 2), width=(6, 6)) # zoom in with (3,2) as the center and a width of (6, 6)\nsliceplot(snap, iv=\"d\", z=0.1, resample=true, dims=(400, 600)) # up/down-scale to a size of (400, 600)\nsliceplot(snap, iv=\"ekin\", z=0.1, linetype=:surf) # surface plot\n\nplot_values_along(snap, [0.5, 0.5, 0.1], dir=3, iv=\"d\") # plot density along z-axis through point (.5, .5, 0.1)\nhistogram_along(snap, [0.5, 0.5, 0.1], dir=3, iv=\"d\", norm=:pdf, label=\"density\") # histogram normalized to probability density\nanim_pane(snap, ax=3, iv=\"d\", nframes=20, start=0.0, stop=-10.0, savepath=\"test.gif\") # animate a panning in z-direction from -10 to 0 ","category":"page"},{"location":"buffers/#The-JuliaDispatch.Buffers-Module","page":"Buffers","title":"The JuliaDispatch.Buffers Module","text":"","category":"section"},{"location":"buffers/","page":"Buffers","title":"Buffers","text":"The purpose of this module is to stitch together all the patch data of a given quantity in to a single array. The module contains functionality for doing this for both a unigrid and a mesh-refined simulation, and for both a 3D and 2D domain. Additionally, it has the ability to down- or upscale the stitched data using gridded bi/tri-linear interpolation, which allows for faster and more memory efficient data extraction.","category":"page"},{"location":"buffers/","page":"Buffers","title":"Buffers","text":"As with the other modules, after having imported ´JuliaDispatch` into your workspace, do","category":"page"},{"location":"buffers/","page":"Buffers","title":"Buffers","text":"using JuliaDispatch.Buffers","category":"page"},{"location":"buffers/#unigrid_plane","page":"Buffers","title":"unigrid_plane","text":"","category":"section"},{"location":"buffers/","page":"Buffers","title":"Buffers","text":"The unigrid_plane function takes in a snapshot and a single physical coordinate at some x/y/z-value and attempts to combine the data using the patches that are found within the given plane. This function returns the entire data set, meaning it does not perform any interpolation when stitching together the data apart from interpolating patch data between planes to get the values at the given coordinate.","category":"page"},{"location":"buffers/","page":"Buffers","title":"Buffers","text":"JuliaDispatch.Buffers.unigrid_plane","category":"page"},{"location":"buffers/#JuliaDispatch.Buffers.unigrid_plane","page":"Buffers","title":"JuliaDispatch.Buffers.unigrid_plane","text":"unigrid_plane(snap::Dict; iv::Union{Int, String}, x::Float, y::Float, z::Float)\n\nReturn a 2d array of joined patch data in a slice at x/y/z. All patches in given plane must have same shape, size, and number of cells. Returns a Dict if iv is a collection, otherwise a Matrix.\n\n\n\n\n\n","category":"function"},{"location":"buffers/#unigrid_volume","page":"Buffers","title":"unigrid_volume","text":"","category":"section"},{"location":"buffers/","page":"Buffers","title":"Buffers","text":"Similar to unigrid_plane except that it returns a 3D array with the entire simulation data set for the given quantity.","category":"page"},{"location":"buffers/","page":"Buffers","title":"Buffers","text":"JuliaDispatch.Buffers.unigrid_volume","category":"page"},{"location":"buffers/#JuliaDispatch.Buffers.unigrid_volume","page":"Buffers","title":"JuliaDispatch.Buffers.unigrid_volume","text":"unigrid_volume(snap::Dict; iv::Union{Int, String}=0, all::Bool=false, verbose::Int=0)\n\nReturn a 3D array of joined patch data of quantity . All patches must have same shape, size, and number of cells.\n\n#Arguments:\n\nsnap::Dict, snapshot\n\n#Kwargs:     - iv::Union{String, Int, Array}, what quantity(/ies) to buffer. if array, output will           be a dictionairy with keys equal to the input variable names, and           values as the 2d-buffers.     - all::Bool, whether to include guard zones (if available)\n\n\n\n\n\n","category":"function"},{"location":"buffers/#amr_plane","page":"Buffers","title":"amr_plane","text":"","category":"section"},{"location":"buffers/","page":"Buffers","title":"Buffers","text":"If the simulation uses mesh-refinement or you want to up/downscale the data from a unigrid experiment, use the amr_plane function. In addition to the standard parameters of unigrid_plane , this function also accepts the dimensions of the returned array containing the interpolated data. The dimensions are given with the keyword argument dims and can be an Integer denoting a square array, or a length-2 array or tuple denoting the dimensions in axis 1 and axis 2. ","category":"page"},{"location":"buffers/","page":"Buffers","title":"Buffers","text":"JuliaDispatch.Buffers.amr_plane","category":"page"},{"location":"buffers/#JuliaDispatch.Buffers.amr_plane","page":"Buffers","title":"JuliaDispatch.Buffers.amr_plane","text":"amr_plane(snap::Dict; iv::Union{Int, String}, x::Float, y::Float, z::Float,\n          dims::Union{Int, Tuple}, all::Bool, span=nothing, verbose=0)\n\nReturn a 2D array containing interpolated data of quantity iv in a slice x/y/z from all patches in a given snapshot. If dims is an Int the resulting array will be of size (dims, dims). If dims is a length-2 tuple, the resulting array will have size (dims...). \n\n\n\n\n\n","category":"function"},{"location":"buffers/#amr_volume","page":"Buffers","title":"amr_volume","text":"","category":"section"},{"location":"buffers/","page":"Buffers","title":"Buffers","text":"Similar to amr_volume but for 3D data.","category":"page"},{"location":"buffers/","page":"Buffers","title":"Buffers","text":"JuliaDispatch.Buffers.amr_volume","category":"page"},{"location":"buffers/#JuliaDispatch.Buffers.amr_volume","page":"Buffers","title":"JuliaDispatch.Buffers.amr_volume","text":"amr_volume(snap::Dict; iv::Union{Int, AbstractArray, String}, all::Bool,\n        dims::Union{Tuple, Int}, verbose::int)\n\nReturn a 3D array containing interpolated data of quantity iv from all patches in a given snapshot. If dims is an Int the resulting array will be of size (dims, dims, dims). If dims is a length-3 array, the array will have size (dims...). \n\n\n\n\n\n","category":"function"},{"location":"analysis/#The-JuliaDispatch.Analysis-Module","page":"The JuliaDispatch.Analysis Module","title":"The JuliaDispatch.Analysis Module","text":"","category":"section"},{"location":"select/#The-JuliaDispatch.Select-Module","page":"Select","title":"The JuliaDispatch.Select Module","text":"","category":"section"},{"location":"select/","page":"Select","title":"Select","text":"This module contains functionality for locating and extracting patches and data at certain locations within the domain. ","category":"page"},{"location":"select/","page":"Select","title":"Select","text":"Modules = [JuliaDispatch.Select]\nPrivate = false","category":"page"},{"location":"select/#JuliaDispatch.Select.box-Tuple{Any}","page":"Select","title":"JuliaDispatch.Select.box","text":"box(patch::Dict; iv::Union{String, Int}, all::Bool, verbose::Int)\n\nReturn 3D-array of data of quantity iv from patch. Shorthand for patch[\"var\"](iv, verbose=verbose, all=all).\n\nExamples\n\njulia> density_box = box(patch, iv=\"d\")\n\n\n\n\n\n","category":"method"},{"location":"select/#JuliaDispatch.Select.corner_indices-Tuple{Any, Any}","page":"Select","title":"JuliaDispatch.Select.corner_indices","text":"corner_indices(snap, patch; dir=1)\n\nGet the corner indices of a given patch in a given direction.\n\n\n\n\n\n","category":"method"},{"location":"select/#JuliaDispatch.Select.corner_indices_all-Tuple{Any, Any}","page":"Select","title":"JuliaDispatch.Select.corner_indices_all","text":"corner_indices_all(snap, patch)\n\nGet the corner indices of a given patch.\n\n\n\n\n\n","category":"method"},{"location":"select/#JuliaDispatch.Select.indices_and_weights","page":"Select","title":"JuliaDispatch.Select.indices_and_weights","text":"indices_and_weights(p::Dict, point = [0.5, 0.5, 0.5], iv = 0)\n\nReturn indices and interpolation weights for a point in a patch p.\n\n\n\n\n\n","category":"function"},{"location":"select/#JuliaDispatch.Select.is_inside-Tuple{Any, Any}","page":"Select","title":"JuliaDispatch.Select.is_inside","text":"is_inside(p::Dict, point::Array)\n\nReturn true/false depending on if point is inside patch.\n\n\n\n\n\n","category":"method"},{"location":"select/#JuliaDispatch.Select.patch_at","page":"Select","title":"JuliaDispatch.Select.patch_at","text":"patch_at(pp, point=[0.5, 0.5, 0.5]; verbose=0)\n\nFind the patch that contains a given point.\n\n\n\n\n\n","category":"function"},{"location":"select/#JuliaDispatch.Select.patches_along","page":"Select","title":"JuliaDispatch.Select.patches_along","text":"patches_along(snap, point=[0.5, 0.5, 0.5]; dir = 1, verbose=0)\n\nGet the patches along a given direction through a point\n\n\n\n\n\n","category":"function"},{"location":"select/#JuliaDispatch.Select.patches_in-Tuple{Any, Any}","page":"Select","title":"JuliaDispatch.Select.patches_in","text":"patches_in(snap::Dict, span::Tuple)\n\nReturn a Vector of patches that lie within a domain spanned by span.\n\n\n\n\n\n","category":"method"},{"location":"select/#JuliaDispatch.Select.patches_in-Tuple{Any}","page":"Select","title":"JuliaDispatch.Select.patches_in","text":"patches_in(snap::Dict; x::Number=nothing, y::Number=nothing, z::Number=nothing)\n\nReturn a Vector of patches that lie within a given plane. \n\n\n\n\n\n","category":"method"},{"location":"select/#JuliaDispatch.Select.plane-Tuple{Any}","page":"Select","title":"JuliaDispatch.Select.plane","text":"plane(patch::Dict; iv::Union{Int, String}, x::Float, y::Float, z::Float,\n            Log::Bool, all::Bool)\n\nFind the plane values of a patch at a given slice x/y/z by interpolating neighbouring planes.\n\nExamples\n\njulia> density_plane = plane(patch, iv=\"d\", z=0.0)\n\n\n\n\n\n","category":"method"},{"location":"select/#JuliaDispatch.Select.values_along","page":"Select","title":"JuliaDispatch.Select.values_along","text":"values_along(snap::Dict, point::Array=[0.5, 0.5, 0.5]; dir::Int=1, iv::Union{String, Int}=0, var=nothing,\n                verbose::Int = 0, all::Bool = false)\n\nReturn s, f(s) with s the coordinates and f the values in the iv slot of data, taken along the direction v – so far restricted to axis values\n\n\n\n\n\n","category":"function"},{"location":"select/#JuliaDispatch.Select.values_along2","page":"Select","title":"JuliaDispatch.Select.values_along2","text":"values_along2(snap::Dict, point::Array=[0.5, 0.5, 0.5]; dir::Int=1, iv::Union{String, Int}=0, var=nothing,\n                verbose::Int = 0, all::Bool = false)\n\nReturn s, f(s) with s the coordinates and f the values in the iv slot of data, taken along the direction v – so far restricted to axis values\n\n\n\n\n\n","category":"function"},{"location":"select/#JuliaDispatch.Select.values_in","page":"Select","title":"JuliaDispatch.Select.values_in","text":"values_in(snap::Dict, point::Array=[0.5, 0.5, 0.5]; dir::Int=1, iv::Union{String, Int}=0, var=nothing,\nverbose::Int = 0, all::Bool = false)\n\nReturn s, f(s) with s the coordinates and f the values in the iv slot of data, taken along the direction v – so far restricted to axis values\n\n\n\n\n\n","category":"function"},{"location":"graphics/#The-JuliaDispatch.Graphics-Module","page":"Graphics","title":"The JuliaDispatch.Graphics Module","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"This module contains various functions for visualizations, including 1D, 2D and 3D plots and simple animations.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"To begin, first import the module into your workspace ","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"using JuliaDispatch.Graphics","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Assuming you already have a snapshot loaded, you can then call the various plotting functions to visualize quantities. All the plotting functions accepts keyword arguments which are supported by the Plots.jl GR backend. See documentation for all possible keyword arguments. This means that you can set title, axis labels, fontsizes, linestyle (lineplot, scatter, heatmap, surface, etc) manually. ","category":"page"},{"location":"graphics/#sliceplot","page":"Graphics","title":"sliceplot","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"The sliceplot function is the main function for plotting a quantity in a given plane. The function is very flexible and includes, among other things, the possibility to zoom in on certain regions by using the center and/or width keyword arguments. If the given combination of center and width extends beyond a boundary, the function will look for periodicity in the snapshot and stitch together the data beyond the boundary with periodic axes.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"By default, sliceplot assumes the snapshot data is not mesh-refined. If it is mesh-refined, make sure the unigrid keyword argument is set to false.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"It it possible to rescale the data by setting the dims keyword argument to either an integer (which will scale the domain to NxN), or a length-2 collection, which scales the domain to NxM. ","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"JuliaDispatch.Graphics.sliceplot","category":"page"},{"location":"graphics/#JuliaDispatch.Graphics.sliceplot","page":"Graphics","title":"JuliaDispatch.Graphics.sliceplot","text":"sliceplot(snap::Dict; x = nothing, y = nothing, z = nothing, unigrid = true, kw...)\n\nMake a sliceplot of quantity iv at the given coordinate. Accepts any keyword argument supported by the Plots.plot() function, in addition to:\n\nArguments\n\nsnap::Dict: snapshot\niv::Union{Int, String, Char}: what quantity to plot. Default 0.\ngrids::Bool: whether to show patch grids. Default false.\nwidth::Tuple{Int, Int}: width of the sub-domain axes. Default nothing (whole plane is plotted). \ncenter::Tuple{Int, Int}:  where to center the plot. Default nothing (center is not moved)\ndims::Union{Tuple{Int, Int}, Int}: size of interpolated slice if experiment uses adaptive mesh-refinement.                                       Can be either tuple indicating size in each dimension, or                                      an integer indicating same size for both dimensions. Default nothing.\n\nExamples\n\njulia> sliceplot(snap, iv=\"ekin\", z=-15.0) # simple sliceplot at z=-15 of kinetic energy\njulia> sliceplot(snap, iv=\"sqrt(bx^2 + by^2 + bz^2)\", x=10) # also accepts expressions \njulia> sliceplot(snap, iv=\"d\", z=1.0, center=(5, 5), width=(4, 2)) # re-centre and zoom in\njulia> sliceplot(snap, iv=\"d\", z=1.0, resample=true, dims=(400, 600)) # resize data to size (400, 600)\n\n\n\n\n\n","category":"function"},{"location":"graphics/#plot_values_along","page":"Graphics","title":"plot_values_along","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"To plot values of a quantity along a given axis through a given point, use the function plot_values_along. This function takes in a snapshot, a point (in the form of a length-3 array) as arguments, and the quantity iv and the axis direction dir as keyword arguments, in addition to any keyword argument accepted by the Plots.plot() function.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"JuliaDispatch.Graphics.plot_values_along","category":"page"},{"location":"graphics/#JuliaDispatch.Graphics.plot_values_along","page":"Graphics","title":"JuliaDispatch.Graphics.plot_values_along","text":"plot_values_along(snap::Dict, pt::Array=[0.5, 0.5, 0.5]; iv = 0, dir = 1, verbose = 0, kw...)\n\nPlot values of quantity iv along direction dir={1,2,3} (x, y, z), through point pt=[x,y,z]. \n\nAccepts any keyword arguments supported by the plot-function exported from Plots.GR(). See  documentation for a complete list.\n\nExamples\n\njulia> plot_values_along(snap, iv=\"ekin\", linetype=:scatter, xlabel=\"x\", ylabel=\"y\") # scatter plot\njulia> plot_values_along(snap, iv=\"T\", dir=3, style=:dashdot, label=\"Temperature\")\njulia> plot_values_along(snap, [0.0, 1.0, 2.0], iv=\"ekin\", title=\"Kinetic Energy\")\n\n\n\n\n\n","category":"function"},{"location":"graphics/#histogram_along","page":"Graphics","title":"histogram_along","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"The function histogram_along computes and plots a histogram of a quantity iv along a direction dir through a point pt. By default the histogram shows the absolute frequency (counts), but can be changed to a probability density or probability by setting the keyword argument norm to, respectively, :pdf or :probability. Additionally you define the bins with the bins keyword argument. ","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"JuliaDispatch.Graphics.histogram_along","category":"page"},{"location":"graphics/#JuliaDispatch.Graphics.histogram_along","page":"Graphics","title":"JuliaDispatch.Graphics.histogram_along","text":"histogram_along(snap::Dict, pt::Array=[0.5, 0.5, 0.5]; iv = 0, dir = 1, verbose = 0, kw...)\n\nPlot a histogram of quantity iv along direction dir through point pt. Accepts any keyword argument accepted by the Plots.histogram function.\n\nExamples\n\njulia> histogram_along(snap, [13.4, 20.5, -15.0], dir=3, iv=\"d\", norm=:pdf, label=\"density\") \n\n\n\n\n\n","category":"function"},{"location":"graphics/#anim_plane","page":"Graphics","title":"anim_plane","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"To produce a time-evolution animation of given quantity in a 2D plane, use the anim_plane function. This function accepts any keyword arguments accepted by sliceplot, in addition to the tspan keyword argument which can be a tuple of numbers denoting at which time (which snapshot) to start and end the simulation. Additionally, the step keyword arguments defines whether to use all snapshots or to skip with a given step value.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"JuliaDispatch.Graphics.anim_plane","category":"page"},{"location":"graphics/#JuliaDispatch.Graphics.anim_plane","page":"Graphics","title":"JuliaDispatch.Graphics.anim_plane","text":"anim_plane(;data=\"../data\", run=\"\", x = nothing, y = nothing, z = nothing, iv=0, \n            tspan=nothing, step=1, savepath=nothing, verbose = 0, kw...)\n\nAnimate a plane of quantity iv at a slice x/y/z. If tspan tuple is not given, all snapshots will be used, otherwise only snapshots with time within the given tspan will be loaded. A frame will be recorded every step, and the resulting animation will be saved to savepath. \n\n\n\n\n\n","category":"function"},{"location":"graphics/#anim_pane","page":"Graphics","title":"anim_pane","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"If you want animate a pane through the computational domain in a certain direction, call the anim_pane function. This function accepts any keyword argument supported by sliceplot in addition to the nframes keyword argument which denotes how many frames will be written to the output video file. By default a pan will be made from the minimum value of the given axis to the maximum value, but this can be overwritten by setting the keyword arguments start and/or stop to desired values. Additionally you can set reverse to true if you would like to pan from the maximum value to the minimum. ","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"JuliaDispatch.Graphics.anim_pane","category":"page"},{"location":"graphics/#JuliaDispatch.Graphics.anim_pane","page":"Graphics","title":"JuliaDispatch.Graphics.anim_pane","text":"anim_pane(snap; ax=1, nframes=10, unigrid=true, iv=iv, reverse=false\n          start=nothing, stop=nothing, verbose=0, savepath = nothing, kw...)\n\nPlot and animate a pane through axis ax from start to stop with nframes frames of quantity iv. Output is saved to savepath. Will go from low to high axis values unless reverse is set to true.\n\n#Examples\n\njulia> anim_pane(snap, ax=3, iv=\"d\", nframes=100, start=0.0, stop=-10.0, savepath=\"test.gif\", reverse=true)\n\n\n\n\n\n","category":"function"},{"location":"graphics/#plot_time_evolution","page":"Graphics","title":"plot_time_evolution","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"JuliaDispatch.Graphics.plot_time_evolution","category":"page"},{"location":"graphics/#JuliaDispatch.Graphics.plot_time_evolution","page":"Graphics","title":"JuliaDispatch.Graphics.plot_time_evolution","text":"plot_time_evolution(snaps::Vector; iv = 0, all=false, domain_average=true, kw...)\n\nPlot the time evolution of quantity iv from a vector of parsed snapshots. If domain_average is true, the quantity will be averaged over the domain (divided by the number of cells). Accepts any keyword argument supported by Plots.plot.\n\n\n\n\n\nplot_time_evolution(;data=\"data\", run=\"\", iv = 0, all=false, domain_average=true, tspan=nothing, kw...)\n\nPlot the time evolution of quantity iv from snapshots in the given data/run folder. If tspan is given, only snapshots within the given time span will be used. If domain_average is true, the quantity will be averaged over the domain (divided by the number of cells). Accepts any keyword argument supported by Plots.plot.\n\n\n\n\n\n","category":"function"},{"location":"#Overview","page":"JuliaDispatch: Analysis and Visualization Tools for Dispatch","title":"Overview","text":"","category":"section"},{"location":"","page":"JuliaDispatch: Analysis and Visualization Tools for Dispatch","title":"JuliaDispatch: Analysis and Visualization Tools for Dispatch","text":"JuliaDispatch.jl is a package developed for analysis and visualization of simulations from the Dispatch framework.","category":"page"},{"location":"","page":"JuliaDispatch: Analysis and Visualization Tools for Dispatch","title":"JuliaDispatch: Analysis and Visualization Tools for Dispatch","text":"Pages = [\"quickstart.md\", \"dispatch.md\", \"graphics.md\", \"select.md\", \"buffers.md\", \"utils.md\"]","category":"page"},{"location":"dispatch/#The-JuliaDispatch.Dispatch-Module","page":"Dispatch","title":"The JuliaDispatch.Dispatch Module","text":"","category":"section"},{"location":"dispatch/","page":"Dispatch","title":"Dispatch","text":"This module contains the snapshot-function, which is used for reading a snapshot and parsing the patches.","category":"page"},{"location":"dispatch/","page":"Dispatch","title":"Dispatch","text":"After having imported the JuliaDispatch module into your workspace, simply do","category":"page"},{"location":"dispatch/","page":"Dispatch","title":"Dispatch","text":"using JuliaDispatch.Dispatch","category":"page"},{"location":"dispatch/","page":"Dispatch","title":"Dispatch","text":"The function snapshot is then available. See end of page for documentation and examples.","category":"page"},{"location":"dispatch/","page":"Dispatch","title":"Dispatch","text":"When reading in a snapshot with the snapshot function, a dictionary will be returned. All the properties of the snapshot can be accessed using square brackets and a string with the name of the property. For example, if you want to know the time at which the snapshot was taken, do","category":"page"},{"location":"dispatch/","page":"Dispatch","title":"Dispatch","text":"println(snap[\"time\"])","category":"page"},{"location":"dispatch/","page":"Dispatch","title":"Dispatch","text":"All the patches and their metadata are stored in the \"patches\" key of the snapshot. This returns a vector with each entry containing the patch metadata in the form of another dictionary. For example","category":"page"},{"location":"dispatch/","page":"Dispatch","title":"Dispatch","text":"patch1 = snap[\"patches\"][1]\nprintln(patch1[\"id\"])","category":"page"},{"location":"dispatch/","page":"Dispatch","title":"Dispatch","text":"extracts the first patch and prints its id.","category":"page"},{"location":"dispatch/","page":"Dispatch","title":"Dispatch","text":"The snapshot function will by default display a progressbar visualizing the progress in parsing the patches. To disable this, set the keyword argument progress to false. To suppress all printed information, which might be useful for when reading in a large number of snapshots at once, set verbose to -1. ","category":"page"},{"location":"dispatch/","page":"Dispatch","title":"Dispatch","text":"JuliaDispatch.Dispatch.snapshot","category":"page"},{"location":"dispatch/#JuliaDispatch.Dispatch.snapshot","page":"Dispatch","title":"JuliaDispatch.Dispatch.snapshot","text":"snapshot(iout::Int; run::String, data::String, progress::Bool=true, suppress::Bool=false,\n         verbose::Int, copy::Bool=false, memmap::Int=1)\n\nParses patches and return a Dict with all properties of snapshot iout in the given data/dir-folder.  Will display patch parsing progress unless progress is set to false. \n\n\n\n\n\n","category":"function"},{"location":"dispatch/","page":"Dispatch","title":"Dispatch","text":"JuliaDispatch.Dispatch.cache_snapshots_live","category":"page"},{"location":"dispatch/#JuliaDispatch.Dispatch.cache_snapshots_live","page":"Dispatch","title":"JuliaDispatch.Dispatch.cache_snapshots_live","text":"cache_snapshots_live(;data=\"data/\", run=\"\", current_snap=0, sleeptime=10)\n\nRead snapshots live as they are being produced by a simulation in the given data/run directory, caching the  namelists for faster loading of snapshots later.  Will start from snapshot current_snap.  Will wait for sleeptime seconds to look again if no new snapshot is found. If program waits for more than maxsleep seconds without finding a new snapshot, the program will exit.\n\n\n\n\n\n","category":"function"},{"location":"dispatch/","page":"Dispatch","title":"Dispatch","text":"JuliaDispatch.Dispatch.get_snapshots","category":"page"},{"location":"dispatch/#JuliaDispatch.Dispatch.get_snapshots","page":"Dispatch","title":"JuliaDispatch.Dispatch.get_snapshots","text":"get_snapshots(;data=data, run=run, tspan=nothing)\n\nReturns a vector of parsed snapshots in the given  data/run folder. If tspan is given, only snapshots with tspan[1] <= \"time\" <= tspan[2] will be parsed and returned.\n\n\n\n\n\n","category":"function"},{"location":"utils/#The-JuliaDispatch.Utils-Module","page":"Utils","title":"The JuliaDispatch.Utils Module","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"Utils contains smaller functions used by other functions within the JuliaDispatch environment. ","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"Modules = [JuliaDispatch.Utils]","category":"page"},{"location":"utils/#JuliaDispatch.Utils._kw_extract-Tuple{Any, Any}","page":"Utils","title":"JuliaDispatch.Utils._kw_extract","text":"_kw_extract(kw, dict)\n\nIf key from dict occurs in kw, pop them \n\n\n\n\n\n","category":"method"},{"location":"utils/#JuliaDispatch.Utils.get_n_patches-Tuple{Any}","page":"Utils","title":"JuliaDispatch.Utils.get_n_patches","text":"get_n_patches(iout; data=\"data\", run=\"\")\n\nReturn the number of patches in the given snapshot iout in the data/run-directory.\n\n\n\n\n\n","category":"method"},{"location":"utils/#JuliaDispatch.Utils.get_n_snapshots-Tuple{}","page":"Utils","title":"JuliaDispatch.Utils.get_n_snapshots","text":"get_n_snapshots(;run=\"\", data=\"../data\")\n\nReturns the total number of snapshots in the given data folder\n\n\n\n\n\n","category":"method"},{"location":"utils/#JuliaDispatch.Utils.get_new_snapshot-Tuple{Any}","page":"Utils","title":"JuliaDispatch.Utils.get_new_snapshot","text":"get_new_snapshot(current_snap; data=\"data/\", run=\"\", sleeptime=10, maxsleep=100)\n\nReturn snapshot id with ID = current_snap + 1. Will wait for new snapshots as they are being produced.  If program waits for more than maxsleep seconds without finding a new snapshot, the program will exit.\n\n\n\n\n\n","category":"method"},{"location":"utils/#JuliaDispatch.Utils.get_snapshot_ids-Tuple{Any}","page":"Utils","title":"JuliaDispatch.Utils.get_snapshot_ids","text":"get_snapshot_ids(tspan::Tuple; data=\"../data\", run=\"\")\n\nReturn an array of IDs of all snapshots in the given data/run-folder whose time ∈ tspan \n\n\n\n\n\n","category":"method"},{"location":"utils/#JuliaDispatch.Utils.get_snapshot_ids-Tuple{}","page":"Utils","title":"JuliaDispatch.Utils.get_snapshot_ids","text":"get_snapshot_ids(;data = \"../data\", run = \"\")\n\nReturn an array of IDs of all snapshots in the given data/run-folder.\n\n\n\n\n\n","category":"method"},{"location":"utils/#JuliaDispatch.Utils.get_snapshot_time","page":"Utils","title":"JuliaDispatch.Utils.get_snapshot_time","text":"get_snapshot_time(iout=nothing; data=\"../data\", run=\"\")\n\nReturn the time of snapshot iout in the given data/run-folder or all snapshots if isnothing(iout).\n\n\n\n\n\n","category":"function"},{"location":"utils/#JuliaDispatch.Utils.get_snapshot_times-Tuple{}","page":"Utils","title":"JuliaDispatch.Utils.get_snapshot_times","text":"get_snapshot_times(; data=\"../data\", run=\"\")\n\nReturn the times of all snapshots in the given data/run-folder.\n\n\n\n\n\n","category":"method"}]
}
